/*!
 * Guardian v0.1.0
 * Data guard and validation library
 * Copyright 2024 Serhii Pimenov
 * Licensed under MIT
 *
 * Build time: 19.07.2024 00:23:05
 */
var Guard=function(r){"use strict";class GuardianError extends Error{constructor(r="",e=null,n){super(r),this.message=r,this.name=e,this.value=n}}const parse=(r,e)=>{let n;if(!r)throw new Error("Schema object required for parse data!");if("function"==typeof r){if(n=r.apply(null,[e]),n instanceof GuardianError)throw n}else for(let t in r){const a=e[t],i=r[t];if(!i)throw new GuardianError(`Guard not defined for field ${t} in input data!`,"general",e);if(!e.hasOwnProperty(t))throw new GuardianError(`Field ${t} doesn't exists in input data!`,"general",e);if("function"==typeof i){if(console.log(i.name),n=i.apply(null,[a]),n instanceof GuardianError)throw n}else parse(i,a)}return e};return r.bigint=(r="VAL must be a bigint")=>function(e){const n=r.replace(/VAL/g,e);return"bigint"==typeof e?e:new GuardianError(n,"bigint",e)},r.compose=(...r)=>e=>r.reduceRight(((r,e)=>e(r)),e),r.date=(r,e="VAL must be valid date object or date string")=>function(r){const n=e.replace(/VAL/g,r);return r instanceof Date||!isNaN(Date.parse(r))?r:new GuardianError(n,"date",r)},r.email=(r="VAL must be a string in valid email format")=>function(e){const n=r.replace(/VAL/g,e);return"string"==typeof e&&/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e)?e:new GuardianError(n,"email",e)},r.endsWith=(r,e="VAL must end with END_VAL")=>function(n){const t=e.replace(/VAL/g,n).replace(/END_VAL/g,r);return"string"==typeof n&&n.endsWith(r)?n:new GuardianError(t,"endsWith",n)},r.func=(r="The value must be a function")=>function(e){return"function"==typeof e?e:new GuardianError(r,"function",e)},r.integer=(r="VAL must be an integer")=>function(e){const n=r.replace(/VAL/g,e);return Number.isInteger(e)?e:new GuardianError(n,"integer",e)},r.maxValue=(r,e="VAL must be a less then MAX_VALUE")=>function(n){const t=e.replace(/VAL/g,n).replace(/MAX_VALUE/g,r),a=+n;return!isNaN(a)&&a<=r?n:new GuardianError(t,"max-value",n)},r.minValue=(r,e="VAL must be a great then MIN_VALUE")=>function(n){const t=e.replace(/VAL/g,n).replace(/MIN_VALUE/g,r),a=+n;return!isNaN(a)&&a>=r?n:new GuardianError(t,"min-value",n)},r.number=(r="VAL must be a valid number")=>function(e){const n=r.replace(/VAL/g,e);return!isNaN(e)?e:new GuardianError(n,"number",e)},r.object=r=>({...r}),r.parse=parse,r.pipe=(...r)=>e=>r.reduce(((r,e)=>e(r)),e),r.required=(r="Any value required")=>function(e){const n=r.replace(/VAL/g,e);return null!=e&&e?e:new GuardianError(n,"required",e)},r.safeInteger=(r="VAL must be an safe integer")=>function(e){const n=r.replace(/VAL/g,e);return Number.isSafeInteger(e)?e:new GuardianError(n,"safeInteger",e)},r.safeParse=(r,e)=>{let n;if(!r)throw new Error("Schema object required for parse data!");if("function"==typeof r){if(n=r.apply(null,[e]),n instanceof GuardianError)return{ok:!1,error:n}}else for(let t in r){const a=e[t],i=r[t];if(i)if("function"==typeof i){if(n=i.apply(null,[e]),n instanceof GuardianError)return{ok:!1,error:n}}else parse(i,a)}return{ok:!0,output:e}},r.startsWith=(r,e="VAL must starts with START_VAL")=>function(n){const t=e.replace(/VAL/g,n).replace(/START_VAL/g,r);return"string"==typeof n&&n.startsWith(r)?n:new GuardianError(t,"startsWith",n)},r.string=(r="VAL must be a string")=>function(e){const n=r.replace(/VAL/g,e);return"string"==typeof e?e:new GuardianError(n,"string",e)},r.symbol=(r="A symbol is required")=>function(e){return"symbol"==typeof e?e:new GuardianError(r,"symbol",e)},r.unknown=()=>function(r){return r},r}({});
