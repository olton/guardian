/*!
 * Guardian v0.1.0
 * Data guard and validation library
 * Copyright 2024 Serhii Pimenov
 * Licensed under MIT
 *
 * Build time: 19.07.2024 12:02:36
 */
var G=function(r){"use strict";class GuardianError extends Error{constructor(r="",e=null,n){super(r),this.message=r,this.name=e,this.value=n}}const parse=(r,e)=>{let n;if(!r)throw new Error("Schema object required for parse data!");if("function"==typeof r){if(n=r.apply(null,[e]),n instanceof GuardianError)throw n}else for(let t in r){const a=e[t],o=r[t];if(!o)throw new GuardianError(`Guard not defined for field ${t} in input data!`,"general",e);if(!e.hasOwnProperty(t))throw new GuardianError(`Field ${t} doesn't exists in input data!`,"general",e);if("function"==typeof o){if(console.log(o.name),n=o.apply(null,[a]),n instanceof GuardianError)throw n}else parse(o,a)}return e};var string=(r="VAL must be a string")=>function(e){const n=r.replace(/VAL/g,e);return"string"==typeof e?e:new GuardianError(n,"string",e)},isValue=r=>null!=r;const e="VAL must be an array of TYPE";return r.array=(r,n=e)=>(r||n||(r=string(),n=e),"string"==typeof r&&(n=r,r=string()),function(e){const t=n.replace(/VAL/g,e).replace(/TYPE/g,r.name);if(!Array.isArray(e))return new GuardianError(t,"array",e);for(let n of e){if(r(n)instanceof GuardianError)return new GuardianError(t,"array",e)}return e}),r.base64=(r="VAL must be a string in valid base 64 format")=>function(e){const n=r.replace(/VAL/g,e);return"string"==typeof e&&/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/.test(e)?e:new GuardianError(n,"base64",e)},r.between=(r,e,n="VAL must be between MIN_VAL and MAX_VAL")=>{if(!isValue(r))throw new Error("MIN_VALUE not defined!");if(!isValue(e))throw new Error("MAX_VALUE not defined!");return function(t){const a=n.replace(/VAL/g,t).replace(/MIN_VAL/g,r).replace(/MAX_VAL/g,e);return"number"==typeof t&&t>=r&&t<=e?t:new GuardianError(a,"between",t)}},r.bigint=(r="VAL must be a bigint")=>function(e){const n=r.replace(/VAL/g,e);return"bigint"==typeof e?e:new GuardianError(n,"bigint",e)},r.boolean=(r="VAL must be a boolean")=>function(e){const n=r.replace(/VAL/g,e);return"boolean"==typeof e?e:new GuardianError(n,"boolean",e)},r.compose=(...r)=>e=>r.reduceRight(((r,e)=>e(r)),e),r.date=(r="VAL must be valid date object or date string")=>function(e){const n=r.replace(/VAL/g,e);return e instanceof Date?e:new GuardianError(n,"date",e)},r.email=(r="VAL must be a string in valid email format")=>function(e){const n=r.replace(/VAL/g,e);return"string"==typeof e&&/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e)?e:new GuardianError(n,"email",e)},r.endsWith=(r,e="VAL must end with END_VAL")=>{if(!isValue(r))throw new Error("END_VALUE not defined!");return function(n){const t=e.replace(/VAL/g,n).replace(/END_VAL/g,r);return"string"==typeof n&&n.endsWith(r)?n:new GuardianError(t,"endsWith",n)}},r.finite=(r="VAL must be a finite number")=>function(e){const n=r.replace(/VAL/g,e);return Number.isFinite(e)?e:new GuardianError(n,"finite",e)},r.func=(r="The value must be a function")=>function(e){return"function"==typeof e?e:new GuardianError(r,"function",e)},r.integer=(r="VAL must be an integer")=>function(e){const n=r.replace(/VAL/g,e);return Number.isInteger(e)?e:new GuardianError(n,"integer",e)},r.maxValue=(r,e="VAL must be a less then MAX_VALUE")=>{if(!isValue(r))throw new Error("MAX_VALUE not defined!");return function(n){const t=e.replace(/VAL/g,n).replace(/MAX_VALUE/g,r),a=+n;return!isNaN(a)&&a<=r?n:new GuardianError(t,"maxValue",n)}},r.minValue=(r,e="VAL must be a great then MIN_VALUE")=>{if(!isValue(r))throw new Error("MIN_VALUE not defined!");return function(n){const t=e.replace(/VAL/g,n).replace(/MIN_VALUE/g,r),a=+n;return!isNaN(a)&&a>=r?n:new GuardianError(t,"minValue",n)}},r.notNumber=(r="VAL can`t be a number")=>function(e){const n=r.replace(/VAL/g,e);return isNaN(e)?e:new GuardianError(n,"not-number",e)},r.number=(r="VAL must be a number")=>function(e){const n=r.replace(/VAL/g,e);//!isNaN(input)
return"number"==typeof e?e:new GuardianError(n,"number",e)},r.object=r=>({...r}),r.parse=parse,r.pipe=(...r)=>e=>r.reduce(((r,e)=>e(r)),e),r.required=(r="Any value required")=>function(e){const n=r.replace(/VAL/g,e);return null!=e&&e?e:new GuardianError(n,"required",e)},r.safeInteger=(r="VAL must be an safe integer")=>function(e){const n=r.replace(/VAL/g,e);return Number.isSafeInteger(e)?e:new GuardianError(n,"safeInteger",e)},r.safeParse=(r,e)=>{let n;if(!r)throw new Error("Schema object required for parse data!");if("function"==typeof r){if(n=r.apply(null,[e]),n instanceof GuardianError)return{ok:!1,error:n}}else for(let t in r){const a=e[t],o=r[t];if(o)if("function"==typeof o){if(n=o.apply(null,[e]),n instanceof GuardianError)return{ok:!1,error:n}}else parse(o,a)}return{ok:!0,output:e}},r.startsWith=(r,e="VAL must starts with START_VAL")=>{if(!isValue(r))throw new Error("START_VALUE not defined!");return function(n){const t=e.replace(/VAL/g,n).replace(/START_VAL/g,r);return"string"==typeof n&&n.startsWith(r)?n:new GuardianError(t,"startsWith",n)}},r.string=string,r.symbol=(r="A symbol is required")=>function(e){return"symbol"==typeof e?e:new GuardianError(r,"symbol",e)},r.unknown=()=>function(r){return r},r}({});
